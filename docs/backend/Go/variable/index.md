# 变量与数据类型

### 1. 变量

在 Go 语言中，变量通过关键字 `var` 定义。默认情况下，Go 编译器能自动推导变量的类型，也可以显式指定变量类型。

例如：

```go
var variable1 = "Hello World"   // 类型将被自动推到为 string
var variable2 int = 10          // 显式指定变量类型为 int
```

对于多变量的声明，Go 语言采用 `var ( ... )` 的形式声明多个变量，例如：

```go
var (
    a int = 1
    b int = 2
    c int = 3
)
```

除此之外 Go 语言还支持**短变量 `:=` 的声明方式**，通过这种方式声明的变量无需手动指出类型以及关键字，例如：

```go
a := 1
```

> [!TIP] 注意： 
> 如果 `:=` 左侧的变量已经存在，则无法通过该方式重新赋值。短变量声明只是常规变量声明的一种语法糖，并且只能用于局部作用域。

#### 1.1 匿名变量

在 Go 语言中，匿名变量用于接收并忽略不需要的返回值，从而避免声明无用变量，使代码更加简洁。

匿名变量使用下划线 `_` 作为变量名，例如：

```go
conn, _ = net.Dial("tcp", "127.0.0.1:8080")
```

> [!IMPORTANT]
> 每一个匿名变量都是相互独立的，互不影响

#### 1.2 常量

在 Go 语言中，常量用于表示值不可更改的量。定义常量时使用关键字 `const`，例如：

```go
const PI = 3.14
```

与变量类似，常量也支持使用 `()` 包裹，来一次性定义多个常量

> [!TIP] 注意： 
> 常量是不可改变的值，在声明时必须赋值，并且之后也不能再被赋值。常量只支持例如数值、字符串或布尔类型的基本类型，**不支持复杂类型（切片、结构体等）**

常量还有一个特点就是：常量可以是无类型的（Untyped）一个常量是可以被赋值给其他类型的变量，这使得其具有了更宽泛的使用性，例如：

```go
const Pi = 3.14

var i int = n     // 合法
var f float64 = n // 也合法
```

#### 1.3 作用域

在 Go 语言中，作用域指的是**变量、函数等标识符可以被访问的范围**。主要分为三类：

1. 包级作用域：在包级别声明的变量和函数在整个包内都可访问，相当于全局作用域。
2. 函数作用域：在函数内部声明的变量只在该函数内可见和访问，属于局部变量。
3. 块级作用域：在代码块（如 if 语句、for 循环等）中声明的变量，只能在该代码块内部访问。

> [!TIP] 注意
> 1. 全局变量必须使用 `var` 或 `const` 关键字进行显式声明
> 2. **变量的访问遵循就近原则：如果在当前块或函数作用域内定义了变量，则优先使用该作用域内的变量；如果没有定义，则会逐级向上查找，直到全局作用域**


#### 1.4 iota

iota 主要用于常量声明中，生成一组自增的数值，通常从 0 开始，每增加一行常量声明，iota 的值自动加 1。例如：

```go
const (
    A = iota
    B           // 1
    C           // 2
    D           // 3 
)
```

iota 只会在同一个常量声明块中自增，如果进入新的常量声明块，那么 iota 会重新从 0 开始计数。例如：

```go
const (
    X = iota // 0
    Y        // 1
)
const (
    Z = iota // 0（重新开始）
)
```

> [!NOTE] 特殊的用法
> 如果在常量声明中使用了省略表达式，那么写一个会自动沿用上一行的完整表达式（包括 iota 的运算）
> ``` go
> const (
>   A = iota       // 0
>   B = iota + 2   // 3
>   C              // 4
>   D = iota       // 3
>)
> ```
> C 之所以为 4，是因为在常量声明中如果省略了表达式，那么下一个会自动沿用上一行的完整表达式（包括 iota 的运算）。此时 iota 的值为 2，表达式为 iota + 2，所以 C = 2 + 2 = 4；而 D 显式写了 iota，此时 iota 的值为 3，所以 D = 3。

#### 1.5 变量的内存模型

### 2. 数据类型
 